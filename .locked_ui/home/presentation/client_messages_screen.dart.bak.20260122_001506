import 'package:flutter/material.dart';

class ClientMessagesScreen extends StatefulWidget {
  const ClientMessagesScreen({super.key});

  @override
  State<ClientMessagesScreen> createState() => _ClientMessagesScreenState();
}

class _ClientMessagesScreenState extends State<ClientMessagesScreen> {
  // Toggle this:
  // - true  => show demo conversations (so you can verify UI/navigation)
  // - false => show the empty-state (realistic when no data yet)
  static const bool _demoMode = true;

  final TextEditingController _search = TextEditingController();

  // Demo conversations (replace later with real data from your backend)
  final List<_Conversation> _demo = const [
    _Conversation(
      id: 't1',
      title: 'Sarah M. (Caregiver)',
      lastMessage: 'Perfect — I can arrive 10 minutes early.',
      minutesAgo: 6,
      unreadCount: 2,
    ),
    _Conversation(
      id: 't2',
      title: 'Agency Support',
      lastMessage: 'Your request was boosted successfully.',
      minutesAgo: 58,
      unreadCount: 0,
    ),
    _Conversation(
      id: 't3',
      title: 'John K. (Caregiver)',
      lastMessage: 'Thanks! What’s the parking situation?',
      minutesAgo: 180,
      unreadCount: 0,
    ),
  ];

  @override
  void dispose() {
    _search.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    final conversations = _demoMode ? _demo : const <_Conversation>[];

    final q = _search.text.trim().toLowerCase();
    final filtered = q.isEmpty
        ? conversations
        : conversations
            .where((c) =>
                c.title.toLowerCase().contains(q) ||
                c.lastMessage.toLowerCase().contains(q))
            .toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Messages'),
        centerTitle: false,
      ),
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 12),
              child: TextField(
                controller: _search,
                onChanged: (_) => setState(() {}),
                decoration: InputDecoration(
                  hintText: 'Search messages…',
                  prefixIcon: const Icon(Icons.search),
                  filled: true,
                  fillColor: theme.colorScheme.surfaceContainerHighest.withOpacity(0.35),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(14),
                    borderSide: BorderSide.none,
                  ),
                ),
              ),
            ),
            Expanded(
              child: filtered.isEmpty
                  ? _EmptyState(
                      demoMode: _demoMode,
                      onTurnOnDemo: () {
                        // If you want a button later, keep this hook.
                        setState(() {});
                      },
                    )
                  : ListView.separated(
                      padding: const EdgeInsets.only(bottom: 16),
                      itemCount: filtered.length,
                      separatorBuilder: (_, __) => const Divider(height: 1),
                      itemBuilder: (context, i) {
                        final c = filtered[i];
                        return _ConversationTile(
                          convo: c,
                          onTap: () {
                            Navigator.of(context).push(
                              MaterialPageRoute(
                                builder: (_) => _ThreadScreenPlaceholder(convo: c),
                              ),
                            );
                          },
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
}

class _EmptyState extends StatelessWidget {
  final bool demoMode;
  final VoidCallback onTurnOnDemo;

  const _EmptyState({
    required this.demoMode,
    required this.onTurnOnDemo,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.chat_bubble_outline, size: 56, color: theme.colorScheme.onSurface.withOpacity(0.6)),
            const SizedBox(height: 14),
            Text(
              'No messages yet',
              style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w700),
            ),
            const SizedBox(height: 8),
            Text(
              'Messages will appear after a caregiver accepts a request.',
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium?.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.7)),
            ),
            const SizedBox(height: 16),
            if (!demoMode)
              FilledButton.icon(
                onPressed: onTurnOnDemo,
                icon: const Icon(Icons.bolt),
                label: const Text('Show demo conversations'),
              ),
          ],
        ),
      ),
    );
  }
}

class _ConversationTile extends StatelessWidget {
  final _Conversation convo;
  final VoidCallback onTap;

  const _ConversationTile({
    required this.convo,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListTile(
      onTap: onTap,
      leading: CircleAvatar(
        child: Text(_initials(convo.title)),
      ),
      title: Text(
        convo.title,
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
        style: theme.textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w700),
      ),
      subtitle: Text(
        convo.lastMessage,
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(
            _timeAgo(convo.minutesAgo),
            style: theme.textTheme.labelSmall?.copyWith(
              color: theme.colorScheme.onSurface.withOpacity(0.6),
            ),
          ),
          const SizedBox(height: 6),
          if (convo.unreadCount > 0)
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
              decoration: BoxDecoration(
                color: theme.colorScheme.primary,
                borderRadius: BorderRadius.circular(999),
              ),
              child: Text(
                '${convo.unreadCount}',
                style: theme.textTheme.labelSmall?.copyWith(
                  color: theme.colorScheme.onPrimary,
                  fontWeight: FontWeight.w800,
                ),
              ),
            ),
        ],
      ),
    );
  }

  static String _initials(String s) {
    final parts = s.trim().split(RegExp(r'\s+'));
    if (parts.isEmpty) return '?';
    final a = parts.first.isNotEmpty ? parts.first[0] : '?';
    final b = parts.length > 1 && parts[1].isNotEmpty ? parts[1][0] : '';
    return (a + b).toUpperCase();
  }

  static String _timeAgo(int minutes) {
    if (minutes < 60) return '${minutes}m';
    final h = (minutes / 60).floor();
    if (h < 24) return '${h}h';
    final d = (h / 24).floor();
    return '${d}d';
  }
}

class _ThreadScreenPlaceholder extends StatelessWidget {
  final _Conversation convo;
  const _ThreadScreenPlaceholder({required this.convo});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(convo.title),
      ),
      body: SafeArea(
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(24),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.forum_outlined, size: 56, color: theme.colorScheme.onSurface.withOpacity(0.6)),
                const SizedBox(height: 14),
                Text(
                  'Thread UI placeholder',
                  style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w800),
                ),
                const SizedBox(height: 8),
                Text(
                  'Next step: connect this to your real chat thread screen + backend messages.',
                  textAlign: TextAlign.center,
                  style: theme.textTheme.bodyMedium?.copyWith(color: theme.colorScheme.onSurface.withOpacity(0.7)),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _Conversation {
  final String id;
  final String title;
  final String lastMessage;
  final int minutesAgo;
  final int unreadCount;

  const _Conversation({
    required this.id,
    required this.title,
    required this.lastMessage,
    required this.minutesAgo,
    required this.unreadCount,
  });
}

String _initials(String s) {
  final parts = s.trim().split(RegExp(r'\s+'));
  if (parts.isEmpty) return '?';
  final a = parts.first.isNotEmpty ? parts.first[0] : '?';
  final b = parts.length > 1 && parts[1].isNotEmpty ? parts[1][0] : '';
  return (a + b).toUpperCase();
}

String _timeAgo(int minutes) {
  if (minutes < 60) return '${minutes}m';
  final h = (minutes / 60).floor();
  if (h < 24) return '${h}h';
  final d = (h / 24).floor();
  return '${d}d';
}
